import os
import tkinter as tk
from tkinter import ttk, scrolledtext
import threading
import queue
import datetime
import socket
import psutil
import pandas as pd
import numpy as np
import joblib
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from concurrent.futures import ThreadPoolExecutor
from multiprocessing import cpu_count, Pool
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import requests

try:
    import scapy.all as scapy
except ImportError:
    import subprocess
    import sys

    subprocess.check_call([sys.executable, "-m", "pip", "install", "scapy"])
    import scapy.all as scapy

# Global flag to control packet sniffing
sniffing = False
file_index = 1
sniff_thread = None

# Queue for thread-safe GUI updates
packet_queue = queue.Queue(maxsize=1000)  # Increase queue size for higher throughput

# Thread pool for handling packet processing
max_workers = min(64, cpu_count() * 2)  # Dynamically adjust thread pool size based on CPU cores
executor = ThreadPoolExecutor(max_workers=max_workers)

# Global threat counts for the pie chart and labels
threat_counts = {"High": 0, "Moderate": 0, "Low": 0, "No Threat": 0}

# Comprehensive threat intelligence feed
threat_intelligence = {
    "ips": {
        "High": ["192.168.1.100", "45.33.32.156", "103.247.36.32"],  # Known malicious IPs
        "Moderate": ["198.51.100.23", "93.184.216.34"],  # Suspicious IPs
        "Low": ["8.8.8.8", "8.8.4.4"]  # Public DNS servers (example only)
    },
    "ports": {
        "High": [6667, 23, 445, 3389],  # IRC, Telnet, SMB, RDP - known for exploits
        "Moderate": [1337, 8080],  # Commonly misused ports
        "Low": [80, 443]  # HTTP (80) / HTTPS (443)
    },
    "protocols": {
        "High": ["UDP Flood", "ICMP Flood", "DNS Tunneling"],  # DDoS, exfiltration
        "Moderate": ["SSDP", "SNMP"],  # Reflective attacks
        "Low": ["HTTP", "HTTPS"]  # Standard traffic
    },
    "payloads": {
        "High": ["shellcode", "Base64EncodedScript", "MaliciousPDF"],  # Known payloads
        "Moderate": ["unusual_binary", "strange_text_file"],  # Suspicious but less common
        "Low": ["regular_data_transfer", "simple_text_message"]  # Normal data
    },
    "domains": {
        "High": ["malicious-domain.com", "bad-domain.xyz", "dodgy-site.pw"],  # Known phishing or C2 domains
        "Moderate": ["newly-registered.com", "suspicious-site.top"],  # Suspicious, but not confirmed malicious
        "Low": ["example.com", "my-safe-site.com"]  # Typically safe domains
    }
}

# Malicious website categories to detect
malicious_categories = ["malware", "phishing", "spyware", "adware", "ransomware", "crypto-mining"]


# Function to fetch the list of malicious IPs from the ipsum repository
def fetch_malicious_ips():
    url = "https://raw.githubusercontent.com/stamparm/ipsum/master/ipsum.txt"
    try:
        response = requests.get(url)
        response.raise_for_status()
        # Parse the response to extract IPs, ignoring comments and headers
        ips = [line.strip() for line in response.text.splitlines() if line and not line.startswith("#")]
        return ips
    except requests.RequestException as e:
        print(f"Failed to fetch malicious IPs: {e}")
        return []


# Function to update threat intelligence with the fetched malicious IPs
def update_threat_intelligence():
    malicious_ips = fetch_malicious_ips()
    if malicious_ips:
        threat_intelligence["ips"]["High"].extend(malicious_ips)
        print(f"Added {len(malicious_ips)} IPs to High threat category.")


# Initialize threat intelligence at the start of your program
update_threat_intelligence()


# Function to update the threat count pie chart
def update_pie_chart():
    figure.clear()
    labels = threat_counts.keys()
    sizes = threat_counts.values()
    if sum(sizes) == 0:  # Avoid drawing if there are no data
        sizes = [1]  # Prevent division by zero
        labels = ["No Threats Detected"]
        plt.pie(sizes, labels=labels, startangle=140, colors=['grey'])
    else:
        plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140, colors=['red', 'orange', 'blue', 'green'])
    plt.axis('equal')
    canvas.draw()

    # Update threat count labels
    high_threat_label.config(text=f"High Threats: {threat_counts['High']}")
    moderate_threat_label.config(text=f"Moderate Threats: {threat_counts['Moderate']}")
    low_threat_label.config(text=f"Low Threats: {threat_counts['Low']}")
    no_threat_label.config(text=f"No Threats: {threat_counts['No Threat']}")


# Function to check if an IP address is public
def is_public_ip(ip_address):
    ip_int = int.from_bytes(socket.inet_aton(ip_address), 'big')
    for start, end in public_ip_ranges:
        if int.from_bytes(socket.inet_aton(start), 'big') <= ip_int <= int.from_bytes(socket.inet_aton(end), 'big'):
            return True
    return False


# Function to resolve IP addresses back to domain names (only public IPs)
def resolve_ip_to_domain(ip_address):
    if not is_public_ip(ip_address):
        return "N/A"
    if ip_address in dns_cache:
        return dns_cache[ip_address]
    try:
        domain_name = socket.gethostbyaddr(ip_address)[0]
        dns_cache[ip_address] = domain_name
        return domain_name
    except (socket.herror, socket.gaierror):
        return "N/A"


# Function to find the process associated with a given IP (only public IPs)
def find_process_by_ip(ip_address):
    if not is_public_ip(ip_address):
        return "Unknown", "N/A", "N/A"
    for conn in psutil.net_connections(kind='inet'):
        if conn.raddr and conn.raddr.ip == ip_address:
            try:
                process = psutil.Process(conn.pid)
                return process.name(), process.pid, process.exe()
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
    return "Unknown", "N/A", "N/A"


# Function to identify the device or network based on the IP address
def identify_device(ip_address):
    if is_public_ip(ip_address):
        try:
            device_name = socket.gethostbyaddr(ip_address)[0]
            return device_name
        except (socket.herror, socket.gaierror):
            return "Unknown Device"
    return "Unknown Device"


# Function to analyze packet (only public IPs)
def analyze_packet(packet):
    packet_info = {
        "src_mac": packet.src if packet.haslayer(scapy.Ether) else "N/A",
        "dst_mac": packet.dst if packet.haslayer(scapy.Ether) else "N/A",
        "source": "N/A",
        "destination": "N/A",
        "protocol": "N/A",
        "sport": "N/A",
        "dport": "N/A",
        "malicious": False,
        "domain": "N/A",
        "resolved_domain": "N/A",
        "app_name": "N/A",
        "app_pid": "N/A",
        "app_exe": "N/A",
        "dns_query": "N/A",
        "device": "Unknown Device",
        "threat_level": "No Threat"  # Default to No Threat
    }

    # Check if the packet has an IP layer and if the IP is public
    if packet.haslayer(scapy.IP):
        packet_info["source"] = packet[scapy.IP].src
        packet_info["destination"] = packet[scapy.IP].dst
        packet_info["protocol"] = packet[scapy.IP].proto

        # Get source and destination ports if available (e.g., for TCP/UDP)
        if packet.haslayer(scapy.TCP) or packet.haslayer(scapy.UDP):
            packet_info["sport"] = packet.sport
            packet_info["dport"] = packet.dport

        packet_info["resolved_domain"] = resolve_ip_to_domain(packet[scapy.IP].dst)

        # Identify the device or network based on the source IP address
        packet_info["device"] = identify_device(packet[scapy.IP].src)

        # Check if the packet is using HTTP (unencrypted traffic on port 80)
        if packet_info["dport"] == 80 or packet_info["sport"] == 80:
            packet_info["threat_level"] = "Moderate"
            packet_info["malicious"] = True

        # Check against threat intelligence feed
        check_threats(packet_info)

    # Check for DNS queries
    if packet.haslayer(scapy.DNSQR):
        dns_query = packet[scapy.DNSQR].qname.decode() if packet[scapy.DNSQR].qname else "N/A"
        packet_info["dns_query"] = dns_query
        print(f"Captured DNS Query: {dns_query}")  # Debugging: Print captured DNS queries

        # Filter out benign DNS queries (like .local services) to reduce noise
        if dns_query.endswith(".local") or "spotify" in dns_query.lower() or "googlecast" in dns_query.lower():
            packet_info["threat_level"] = "No Threat"
            packet_info["malicious"] = False
            return packet_info  # Return early to avoid counting these as threats

        for domain in threat_intelligence["domains"]["High"] + threat_intelligence["domains"]["Moderate"] + \
                      threat_intelligence["domains"]["Low"]:
            if domain in dns_query:
                packet_info["domain"] = domain
                break
        for category in malicious_categories:
            if category in dns_query.lower():
                packet_info["threat_level"] = "High"
                packet_info["malicious"] = True

    return packet_info


# Function to determine if the packet is a broadcast or contains only MAC addresses
def is_broadcast_or_mac_only(packet_info):
    # Check if the packet only has MAC addresses and no other meaningful data
    if packet_info["source"] == "N/A" and packet_info["destination"] == "N/A" and packet_info["dns_query"] == "N/A":
        return True
    # Check if the packet is a broadcast
    if packet_info["dst_mac"] == "ff:ff:ff:ff:ff:ff":
        return True
    return False


# Function to check packet info against threat intelligence
def check_threats(packet_info):
    # Check IPs
    for level, ips in threat_intelligence["ips"].items():
        if packet_info["source"] in ips or packet_info["destination"] in ips:
            packet_info["malicious"] = True
            packet_info["threat_level"] = level
            break

    # Check ports
    if not packet_info["malicious"]:
        for level, ports in threat_intelligence["ports"].items():
            if packet_info["sport"] in ports or packet_info["dport"] in ports:
                packet_info["malicious"] = True
                packet_info["threat_level"] = level
                break

    # Check protocols
    if not packet_info["malicious"]:
        for level, protocols in threat_intelligence["protocols"].items():
            if packet_info["protocol"] in protocols:
                packet_info["malicious"] = True
                packet_info["threat_level"] = level
                break

    # Check domains
    if not packet_info["malicious"] and packet_info["resolved_domain"] != "N/A":
        for level, domains in threat_intelligence["domains"].items():
            if packet_info["resolved_domain"] in domains:
                packet_info["malicious"] = True
                packet_info["threat_level"] = level
                break

    # Update threat counts only if the packet is actually a threat
    if packet_info["malicious"]:
        threat_counts[packet_info["threat_level"]] += 1

    update_pie_chart()


# Function to display packet in GUI
def display_packet(packet):
    packet_info = analyze_packet(packet)

    # Filter out broadcast and MAC-only packets
    if is_broadcast_or_mac_only(packet_info):
        return

    # Ensure the threat count is not increased for non-threatening packets
    if not packet_info['malicious']:
        threat_counts["No Threat"] += 1

    # Color coding based on threat level
    if packet_info['threat_level'] == 'High':
        color = "red"
    elif packet_info['threat_level'] == 'Moderate':
        color = "yellow"
    elif packet_info['threat_level'] == 'Low':
        color = "blue"
    else:
        color = "green"

    display_text = ", ".join(
        [f"Source MAC: {packet_info['src_mac']}" if packet_info['src_mac'] != "N/A" else "",
         f"Destination MAC: {packet_info['dst_mac']}" if packet_info['dst_mac'] != "N/A" else "",
         f"Source IP: {packet_info['source']}",
         f"Destination IP: {packet_info['destination']}",
         f"Protocol: {packet_info['protocol']}" if packet_info['protocol'] != "N/A" else "",
         f"Source Port: {packet_info['sport']}" if packet_info['sport'] != "N/A" else "",
         f"Destination Port: {packet_info['dport']}" if packet_info['dport'] != "N/A" else "",
         f"DNS Query: {packet_info['dns_query']}" if packet_info['dns_query'] != "N/A" else "",
         f"Domain: {packet_info['domain']}" if packet_info['domain'] != "N/A" else "",
         f"Resolved Domain: {packet_info['resolved_domain']}" if packet_info['resolved_domain'] != "N/A" else "",
         f"Device: {packet_info['device']}" if packet_info['device'] != "Unknown Device" else "",
         f"Threat Level: {packet_info['threat_level']}" if packet_info['malicious'] else "No Threat",
         " [MALICIOUS]" if packet_info["malicious"] else ""
         ]).replace(", ,", "").strip(", ")

    display_text += "\n"
    packet_queue.put((display_text, color))

    # Update the pie chart to reflect changes in the threat counts
    update_pie_chart()


# Function to start packet sniffing
def start_sniffing():
    global sniffing, sniff_thread
    sniffing = True
    scrolled_text.insert(tk.END, "Starting packet sniffing...\n", "info")
    scrolled_text.see(tk.END)

    # Reset file index
    file_index = 1

    def sniff_packets():
        while sniffing:
            scapy.sniff(prn=lambda pkt: executor.submit(display_packet, pkt), store=False)

    sniff_thread = threading.Thread(target=sniff_packets)
    sniff_thread.start()
    root.after(100, process_queue)


# Function to stop packet sniffing
def stop_sniffing():
    global sniffing, sniff_thread
    sniffing = False

    scrolled_text.insert(tk.END, "Stopping packet sniffing...\n", "info")
    scrolled_text.see(tk.END)

    # Wait for all threads to finish processing packets
    executor.shutdown(wait=True)

    if sniff_thread and sniff_thread.is_alive():
        sniff_thread.join(timeout=2)

    scrolled_text.insert(tk.END, "Sniffing stopped.\n", "info")
    scrolled_text.see(tk.END)


# Function to process queue and update GUI
def process_queue():
    while not packet_queue.empty():
        display_text, color = packet_queue.get()
        scrolled_text.insert(tk.END, display_text, color)
        scrolled_text.see(tk.END)
    if sniffing:
        root.after(100, process_queue)


# Function to clear packet data when generating a report
def clear_packet_data():
    scrolled_text.delete(1.0, tk.END)


# Function to generate structured report including all packets with their severity level
def generate_report():
    global file_index
    # Stop sniffing before generating the report
    stop_sniffing()

    report_text = "Packet Sniffing Report\n"
    report_text += "=" * 30 + "\n\n"
    report_text += f"Report Generated on: {datetime.datetime.now()}\n"
    report_text += "\nSniffing Details:\n"
    report_text += "-" * 20 + "\n"

    packets = scrolled_text.get(1.0, tk.END).strip().split('\n')
    packet_data = [packet for packet in packets if "Starting packet sniffing" not in packet and "Stopping packet sniffing" not in packet and packet.strip()]

    report_text += f"Total Packets Captured: {len(packet_data)}\n\n"
    report_text += "Packet Information:\n"
    report_text += "-" * 20 + "\n"

    for i, packet in enumerate(packet_data, start=1):
        report_text += f"Packet {i}:\n{packet}\n\n"

    # Write the report to the scrolled text widget
    report_scrolled_text.delete(1.0, tk.END)
    report_scrolled_text.insert(tk.END, report_text, "report")

    # Save the report to a file
    desktop_path = "C:/Users/patri/OneDrive/Desktop"
    while os.path.exists(os.path.join(desktop_path, f'packet_report_{file_index}.txt')):
        file_index += 1
    report_file_path = os.path.join(desktop_path, f'packet_report_{file_index}.txt')
    with open(report_file_path, "w") as report_file:
        report_file.write(report_text)

    scrolled_text.insert(tk.END, f"Report generated and saved as '{report_file_path}'\n", "info")
    scrolled_text.see(tk.END)

    # Clear packet data after generating the report
    clear_packet_data()



# Initialize main window
root = tk.Tk()
root.title("Packet Sniffing and Network Traffic Analysis")
root.geometry("1400x800")  # Adjusted for pie chart display

# Set up styles
style = ttk.Style()
style.theme_use('clam')

# Define colors for the "hacker-themed" appearance
bg_color = "#000000"  # Very black background
fg_color = "#00FF00"  # Green text
info_color = "#00FF00"  # Green text for info

style.configure('TFrame', background=bg_color)
style.configure('TLabel', background=bg_color, foreground=fg_color)
style.configure('TButton', background=bg_color, foreground=fg_color, borderwidth=1)
style.map('TButton', background=[('active', '#333333')], foreground=[('active', fg_color)])

root.configure(bg=bg_color)

# Add a frame for controls
control_frame = ttk.Frame(root)
control_frame.pack(side=tk.TOP, fill=tk.X)

# Add a frame for displaying results
display_frame = ttk.Frame(root)
display_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

# Add a scrolled text widget for showing packet data
scrolled_text = scrolledtext.ScrolledText(display_frame, wrap=tk.WORD, background=bg_color, foreground=fg_color,
                                          insertbackground=fg_color, font=("Consolas", 12))
scrolled_text.tag_configure("info", foreground=info_color)
scrolled_text.tag_configure("packet", foreground=fg_color)
scrolled_text.tag_configure("red", foreground="red")
scrolled_text.tag_configure("yellow", foreground="yellow")
scrolled_text.tag_configure("blue", foreground="blue")
scrolled_text.tag_configure("green", foreground="green")
scrolled_text.pack(fill=tk.BOTH, expand=True)

# Add a frame for displaying report
report_frame = ttk.Frame(root)
report_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

# Add a scrolled text widget for showing the report
report_scrolled_text = scrolledtext.ScrolledText(report_frame, wrap=tk.WORD,
                                                 background=bg_color,
                                                 foreground=fg_color,
                                                 insertbackground=fg_color,
                                                 font=("Consolas", 12))
report_scrolled_text.tag_configure("report", foreground=fg_color)
report_scrolled_text.pack(fill=tk.BOTH, expand=True)

# Add a frame for displaying the threat count pie chart and live threat counts
pie_chart_frame = ttk.Frame(root)
pie_chart_frame.pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)

# Create a figure for the pie chart
figure = plt.Figure(figsize=(5, 4), dpi=100)
canvas = FigureCanvasTkAgg(figure, pie_chart_frame)
canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

# Add labels for live threat counts
high_threat_label = ttk.Label(control_frame, text="High Threats: 0")
high_threat_label.pack(side=tk.LEFT, padx=5, pady=5)

moderate_threat_label = ttk.Label(control_frame, text="Moderate Threats: 0")
moderate_threat_label.pack(side=tk.LEFT, padx=5, pady=5)

low_threat_label = ttk.Label(control_frame, text="Low Threats: 0")
low_threat_label.pack(side=tk.LEFT, padx=5, pady=5)

no_threat_label = ttk.Label(control_frame, text="No Threats: 0")
no_threat_label.pack(side=tk.LEFT, padx=5, pady=5)


# Initialize the pie chart with no data
def initialize_pie_chart():
    labels = threat_counts.keys()
    sizes = threat_counts.values()
    if sum(sizes) == 0:  # Avoid drawing if there is no data
        sizes = [1]  # Prevent division by zero
        labels = ["No Threats Detected"]
        plt.pie(sizes, labels=labels, startangle=140, colors=['grey'])
    else:
        plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140, colors=['red', 'orange', 'blue', 'green'])
    plt.axis('equal')
    canvas.draw()


# Add start, stop, and generate report buttons
start_button = ttk.Button(control_frame, text="Start Sniffing", command=start_sniffing)
stop_button = ttk.Button(control_frame, text="Stop Sniffing", command=stop_sniffing)
generate_report_button = ttk.Button(control_frame, text="Generate Report", command=generate_report)

start_button.pack(side=tk.LEFT, padx=5, pady=5)
stop_button.pack(side=tk.LEFT, padx=5, pady=5)
generate_report_button.pack(side=tk.LEFT, padx=5, pady=5)

# Initialize the pie chart and run the GUI loop
initialize_pie_chart()
root.mainloop()
